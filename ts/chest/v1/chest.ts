// @generated by protobuf-ts 2.9.4
// @generated from protobuf file "chest/v1/chest.proto" (package "chest.v1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Timestamp } from "../../google/protobuf/timestamp";
/**
 * @generated from protobuf message chest.v1.ListChestsRequest
 */
export interface ListChestsRequest {
    /**
     * @generated from protobuf field: chest.v1.TgUser user = 1;
     */
    user?: TgUser;
    /**
     * @generated from protobuf field: chest.v1.ChestId id = 2;
     */
    id?: ChestId;
    /**
     * @generated from protobuf field: chest.v1.TgBot bot = 15;
     */
    bot?: TgBot;
}
/**
 * @generated from protobuf message chest.v1.TgBot
 */
export interface TgBot {
    /**
     * @generated from protobuf field: int64 id = 1;
     */
    id: bigint;
}
/**
 * @generated from protobuf message chest.v1.TgUser
 */
export interface TgUser {
    /**
     * @generated from protobuf field: int64 id = 1;
     */
    id: bigint;
}
/**
 * TODO: can this be unsigned?
 *
 * @generated from protobuf message chest.v1.ChestId
 */
export interface ChestId {
    /**
     * @generated from protobuf field: sint64 id = 1;
     */
    id: bigint;
}
/**
 * @generated from protobuf message chest.v1.ListChestsResponse
 */
export interface ListChestsResponse {
    /**
     * @generated from protobuf field: repeated chest.v1.Chest chests = 1;
     */
    chests: Chest[];
    /**
     * @generated from protobuf field: optional uint32 selected = 2;
     */
    selected?: number;
    /**
     * key in map cannot be bytes or message type
     *
     * @generated from protobuf field: map<sint64, chest.v1.Chest> by_id = 3;
     */
    byId: {
        [key: string]: Chest;
    };
    /**
     * @generated from protobuf field: chest.v1.ChestId selected_id = 4;
     */
    selectedId?: ChestId;
}
/**
 * @generated from protobuf message chest.v1.Chest
 */
export interface Chest {
    /**
     * @generated from protobuf field: chest.v1.ChestId id = 1;
     */
    id?: ChestId;
    /**
     * @generated from protobuf field: chest.v1.ChestType variety = 2;
     */
    variety: ChestType;
    /**
     * @generated from protobuf oneof: state
     */
    state: {
        oneofKind: "tried";
        /**
         * at least this many unique codes have been tried
         *
         * @generated from protobuf field: uint32 tried = 3;
         */
        tried: number;
    } | {
        oneofKind: "waiting";
        /**
         * user has to wait until timestamp to try again
         *
         * @generated from protobuf field: google.protobuf.Timestamp waiting = 4;
         */
        waiting: Timestamp;
    } | {
        oneofKind: "solvedBy";
        /**
         * the chest is solved by someone
         *
         * @generated from protobuf field: string solved_by = 5;
         */
        solvedBy: string;
    } | {
        oneofKind: "expired";
        /**
         * the chest expired without being solved
         *
         * @generated from protobuf field: google.protobuf.Timestamp expired = 6;
         */
        expired: Timestamp;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: bool selected = 15;
     */
    selected: boolean;
}
/**
 * @generated from protobuf message chest.v1.GetTrymapRequest
 */
export interface GetTrymapRequest {
    /**
     * @generated from protobuf field: chest.v1.ChestId id = 1;
     */
    id?: ChestId;
    /**
     * @generated from protobuf field: chest.v1.TgBot bot = 15;
     */
    bot?: TgBot;
}
/**
 * @generated from protobuf message chest.v1.GetTrymapResponse
 */
export interface GetTrymapResponse {
    /**
     * bitmap of attempts made by all users
     * zero length unless it is the current chest
     *
     * @generated from protobuf field: bytes trymap = 1;
     */
    trymap: Uint8Array;
}
/**
 * @generated from protobuf message chest.v1.SubmitGuessRequest
 */
export interface SubmitGuessRequest {
    /**
     * @generated from protobuf field: chest.v1.ChestId id = 1;
     */
    id?: ChestId;
    /**
     * @generated from protobuf field: uint32 guess = 2;
     */
    guess: number;
    /**
     * @generated from protobuf field: chest.v1.TgBot bot = 15;
     */
    bot?: TgBot;
}
/**
 * Should a conflict be a different state or an error status?
 *
 * @generated from protobuf message chest.v1.SubmitGuessResponse
 */
export interface SubmitGuessResponse {
    /**
     * @generated from protobuf field: bool won = 1;
     */
    won: boolean;
}
/**
 * @generated from protobuf message chest.v1.SetNotificationRequest
 */
export interface SetNotificationRequest {
    /**
     * @generated from protobuf field: chest.v1.ChestId id = 1;
     */
    id?: ChestId;
    /**
     * @generated from protobuf field: bool enable_notificatons = 2;
     */
    enableNotificatons: boolean;
    /**
     * @generated from protobuf field: chest.v1.TgBot bot = 15;
     */
    bot?: TgBot;
}
/**
 * @generated from protobuf message chest.v1.SetNotificationResponse
 */
export interface SetNotificationResponse {
}
/**
 * @generated from protobuf enum chest.v1.ChestType
 */
export enum ChestType {
    /**
     * @generated from protobuf enum value: CHEST_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: CHEST_TYPE_REGULAR = 1;
     */
    REGULAR = 1,
    /**
     * @generated from protobuf enum value: CHEST_TYPE_PROMOTIONAL = 2;
     */
    PROMOTIONAL = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class ListChestsRequest$Type extends MessageType<ListChestsRequest> {
    constructor() {
        super("chest.v1.ListChestsRequest", [
            { no: 1, name: "user", kind: "message", T: () => TgUser },
            { no: 2, name: "id", kind: "message", T: () => ChestId },
            { no: 15, name: "bot", kind: "message", T: () => TgBot }
        ]);
    }
    create(value?: PartialMessage<ListChestsRequest>): ListChestsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ListChestsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListChestsRequest): ListChestsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* chest.v1.TgUser user */ 1:
                    message.user = TgUser.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                case /* chest.v1.ChestId id */ 2:
                    message.id = ChestId.internalBinaryRead(reader, reader.uint32(), options, message.id);
                    break;
                case /* chest.v1.TgBot bot */ 15:
                    message.bot = TgBot.internalBinaryRead(reader, reader.uint32(), options, message.bot);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListChestsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* chest.v1.TgUser user = 1; */
        if (message.user)
            TgUser.internalBinaryWrite(message.user, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* chest.v1.ChestId id = 2; */
        if (message.id)
            ChestId.internalBinaryWrite(message.id, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* chest.v1.TgBot bot = 15; */
        if (message.bot)
            TgBot.internalBinaryWrite(message.bot, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message chest.v1.ListChestsRequest
 */
export const ListChestsRequest = new ListChestsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TgBot$Type extends MessageType<TgBot> {
    constructor() {
        super("chest.v1.TgBot", [
            { no: 1, name: "id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<TgBot>): TgBot {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        if (value !== undefined)
            reflectionMergePartial<TgBot>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TgBot): TgBot {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 id */ 1:
                    message.id = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TgBot, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).int64(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message chest.v1.TgBot
 */
export const TgBot = new TgBot$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TgUser$Type extends MessageType<TgUser> {
    constructor() {
        super("chest.v1.TgUser", [
            { no: 1, name: "id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<TgUser>): TgUser {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        if (value !== undefined)
            reflectionMergePartial<TgUser>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TgUser): TgUser {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 id */ 1:
                    message.id = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TgUser, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).int64(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message chest.v1.TgUser
 */
export const TgUser = new TgUser$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChestId$Type extends MessageType<ChestId> {
    constructor() {
        super("chest.v1.ChestId", [
            { no: 1, name: "id", kind: "scalar", T: 18 /*ScalarType.SINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ChestId>): ChestId {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        if (value !== undefined)
            reflectionMergePartial<ChestId>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChestId): ChestId {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sint64 id */ 1:
                    message.id = reader.sint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChestId, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sint64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).sint64(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message chest.v1.ChestId
 */
export const ChestId = new ChestId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListChestsResponse$Type extends MessageType<ListChestsResponse> {
    constructor() {
        super("chest.v1.ListChestsResponse", [
            { no: 1, name: "chests", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Chest },
            { no: 2, name: "selected", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "by_id", kind: "map", K: 18 /*ScalarType.SINT64*/, V: { kind: "message", T: () => Chest } },
            { no: 4, name: "selected_id", kind: "message", T: () => ChestId }
        ]);
    }
    create(value?: PartialMessage<ListChestsResponse>): ListChestsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.chests = [];
        message.byId = {};
        if (value !== undefined)
            reflectionMergePartial<ListChestsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListChestsResponse): ListChestsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated chest.v1.Chest chests */ 1:
                    message.chests.push(Chest.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint32 selected */ 2:
                    message.selected = reader.uint32();
                    break;
                case /* map<sint64, chest.v1.Chest> by_id */ 3:
                    this.binaryReadMap3(message.byId, reader, options);
                    break;
                case /* chest.v1.ChestId selected_id */ 4:
                    message.selectedId = ChestId.internalBinaryRead(reader, reader.uint32(), options, message.selectedId);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: ListChestsResponse["byId"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof ListChestsResponse["byId"] | undefined, val: ListChestsResponse["byId"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.sint64().toString();
                    break;
                case 2:
                    val = Chest.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field chest.v1.ListChestsResponse.by_id");
            }
        }
        map[key ?? "0"] = val ?? Chest.create();
    }
    internalBinaryWrite(message: ListChestsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated chest.v1.Chest chests = 1; */
        for (let i = 0; i < message.chests.length; i++)
            Chest.internalBinaryWrite(message.chests[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 selected = 2; */
        if (message.selected !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.selected);
        /* map<sint64, chest.v1.Chest> by_id = 3; */
        for (let k of globalThis.Object.keys(message.byId)) {
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.Varint).sint64(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Chest.internalBinaryWrite(message.byId[k], writer, options);
            writer.join().join();
        }
        /* chest.v1.ChestId selected_id = 4; */
        if (message.selectedId)
            ChestId.internalBinaryWrite(message.selectedId, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message chest.v1.ListChestsResponse
 */
export const ListChestsResponse = new ListChestsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Chest$Type extends MessageType<Chest> {
    constructor() {
        super("chest.v1.Chest", [
            { no: 1, name: "id", kind: "message", T: () => ChestId },
            { no: 2, name: "variety", kind: "enum", T: () => ["chest.v1.ChestType", ChestType, "CHEST_TYPE_"] },
            { no: 3, name: "tried", kind: "scalar", oneof: "state", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "waiting", kind: "message", oneof: "state", T: () => Timestamp },
            { no: 5, name: "solved_by", kind: "scalar", oneof: "state", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "expired", kind: "message", oneof: "state", T: () => Timestamp },
            { no: 15, name: "selected", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Chest>): Chest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.variety = 0;
        message.state = { oneofKind: undefined };
        message.selected = false;
        if (value !== undefined)
            reflectionMergePartial<Chest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Chest): Chest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* chest.v1.ChestId id */ 1:
                    message.id = ChestId.internalBinaryRead(reader, reader.uint32(), options, message.id);
                    break;
                case /* chest.v1.ChestType variety */ 2:
                    message.variety = reader.int32();
                    break;
                case /* uint32 tried */ 3:
                    message.state = {
                        oneofKind: "tried",
                        tried: reader.uint32()
                    };
                    break;
                case /* google.protobuf.Timestamp waiting */ 4:
                    message.state = {
                        oneofKind: "waiting",
                        waiting: Timestamp.internalBinaryRead(reader, reader.uint32(), options, (message.state as any).waiting)
                    };
                    break;
                case /* string solved_by */ 5:
                    message.state = {
                        oneofKind: "solvedBy",
                        solvedBy: reader.string()
                    };
                    break;
                case /* google.protobuf.Timestamp expired */ 6:
                    message.state = {
                        oneofKind: "expired",
                        expired: Timestamp.internalBinaryRead(reader, reader.uint32(), options, (message.state as any).expired)
                    };
                    break;
                case /* bool selected */ 15:
                    message.selected = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Chest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* chest.v1.ChestId id = 1; */
        if (message.id)
            ChestId.internalBinaryWrite(message.id, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* chest.v1.ChestType variety = 2; */
        if (message.variety !== 0)
            writer.tag(2, WireType.Varint).int32(message.variety);
        /* uint32 tried = 3; */
        if (message.state.oneofKind === "tried")
            writer.tag(3, WireType.Varint).uint32(message.state.tried);
        /* google.protobuf.Timestamp waiting = 4; */
        if (message.state.oneofKind === "waiting")
            Timestamp.internalBinaryWrite(message.state.waiting, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* string solved_by = 5; */
        if (message.state.oneofKind === "solvedBy")
            writer.tag(5, WireType.LengthDelimited).string(message.state.solvedBy);
        /* google.protobuf.Timestamp expired = 6; */
        if (message.state.oneofKind === "expired")
            Timestamp.internalBinaryWrite(message.state.expired, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* bool selected = 15; */
        if (message.selected !== false)
            writer.tag(15, WireType.Varint).bool(message.selected);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message chest.v1.Chest
 */
export const Chest = new Chest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTrymapRequest$Type extends MessageType<GetTrymapRequest> {
    constructor() {
        super("chest.v1.GetTrymapRequest", [
            { no: 1, name: "id", kind: "message", T: () => ChestId },
            { no: 15, name: "bot", kind: "message", T: () => TgBot }
        ]);
    }
    create(value?: PartialMessage<GetTrymapRequest>): GetTrymapRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetTrymapRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTrymapRequest): GetTrymapRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* chest.v1.ChestId id */ 1:
                    message.id = ChestId.internalBinaryRead(reader, reader.uint32(), options, message.id);
                    break;
                case /* chest.v1.TgBot bot */ 15:
                    message.bot = TgBot.internalBinaryRead(reader, reader.uint32(), options, message.bot);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTrymapRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* chest.v1.ChestId id = 1; */
        if (message.id)
            ChestId.internalBinaryWrite(message.id, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* chest.v1.TgBot bot = 15; */
        if (message.bot)
            TgBot.internalBinaryWrite(message.bot, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message chest.v1.GetTrymapRequest
 */
export const GetTrymapRequest = new GetTrymapRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTrymapResponse$Type extends MessageType<GetTrymapResponse> {
    constructor() {
        super("chest.v1.GetTrymapResponse", [
            { no: 1, name: "trymap", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<GetTrymapResponse>): GetTrymapResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.trymap = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<GetTrymapResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTrymapResponse): GetTrymapResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes trymap */ 1:
                    message.trymap = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTrymapResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes trymap = 1; */
        if (message.trymap.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.trymap);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message chest.v1.GetTrymapResponse
 */
export const GetTrymapResponse = new GetTrymapResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubmitGuessRequest$Type extends MessageType<SubmitGuessRequest> {
    constructor() {
        super("chest.v1.SubmitGuessRequest", [
            { no: 1, name: "id", kind: "message", T: () => ChestId },
            { no: 2, name: "guess", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 15, name: "bot", kind: "message", T: () => TgBot }
        ]);
    }
    create(value?: PartialMessage<SubmitGuessRequest>): SubmitGuessRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.guess = 0;
        if (value !== undefined)
            reflectionMergePartial<SubmitGuessRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubmitGuessRequest): SubmitGuessRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* chest.v1.ChestId id */ 1:
                    message.id = ChestId.internalBinaryRead(reader, reader.uint32(), options, message.id);
                    break;
                case /* uint32 guess */ 2:
                    message.guess = reader.uint32();
                    break;
                case /* chest.v1.TgBot bot */ 15:
                    message.bot = TgBot.internalBinaryRead(reader, reader.uint32(), options, message.bot);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubmitGuessRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* chest.v1.ChestId id = 1; */
        if (message.id)
            ChestId.internalBinaryWrite(message.id, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 guess = 2; */
        if (message.guess !== 0)
            writer.tag(2, WireType.Varint).uint32(message.guess);
        /* chest.v1.TgBot bot = 15; */
        if (message.bot)
            TgBot.internalBinaryWrite(message.bot, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message chest.v1.SubmitGuessRequest
 */
export const SubmitGuessRequest = new SubmitGuessRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubmitGuessResponse$Type extends MessageType<SubmitGuessResponse> {
    constructor() {
        super("chest.v1.SubmitGuessResponse", [
            { no: 1, name: "won", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SubmitGuessResponse>): SubmitGuessResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.won = false;
        if (value !== undefined)
            reflectionMergePartial<SubmitGuessResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubmitGuessResponse): SubmitGuessResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool won */ 1:
                    message.won = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubmitGuessResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool won = 1; */
        if (message.won !== false)
            writer.tag(1, WireType.Varint).bool(message.won);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message chest.v1.SubmitGuessResponse
 */
export const SubmitGuessResponse = new SubmitGuessResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetNotificationRequest$Type extends MessageType<SetNotificationRequest> {
    constructor() {
        super("chest.v1.SetNotificationRequest", [
            { no: 1, name: "id", kind: "message", T: () => ChestId },
            { no: 2, name: "enable_notificatons", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "bot", kind: "message", T: () => TgBot }
        ]);
    }
    create(value?: PartialMessage<SetNotificationRequest>): SetNotificationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.enableNotificatons = false;
        if (value !== undefined)
            reflectionMergePartial<SetNotificationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetNotificationRequest): SetNotificationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* chest.v1.ChestId id */ 1:
                    message.id = ChestId.internalBinaryRead(reader, reader.uint32(), options, message.id);
                    break;
                case /* bool enable_notificatons */ 2:
                    message.enableNotificatons = reader.bool();
                    break;
                case /* chest.v1.TgBot bot */ 15:
                    message.bot = TgBot.internalBinaryRead(reader, reader.uint32(), options, message.bot);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetNotificationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* chest.v1.ChestId id = 1; */
        if (message.id)
            ChestId.internalBinaryWrite(message.id, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool enable_notificatons = 2; */
        if (message.enableNotificatons !== false)
            writer.tag(2, WireType.Varint).bool(message.enableNotificatons);
        /* chest.v1.TgBot bot = 15; */
        if (message.bot)
            TgBot.internalBinaryWrite(message.bot, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message chest.v1.SetNotificationRequest
 */
export const SetNotificationRequest = new SetNotificationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetNotificationResponse$Type extends MessageType<SetNotificationResponse> {
    constructor() {
        super("chest.v1.SetNotificationResponse", []);
    }
    create(value?: PartialMessage<SetNotificationResponse>): SetNotificationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SetNotificationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetNotificationResponse): SetNotificationResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SetNotificationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message chest.v1.SetNotificationResponse
 */
export const SetNotificationResponse = new SetNotificationResponse$Type();
/**
 * @generated ServiceType for protobuf service chest.v1.CipherChestService
 */
export const CipherChestService = new ServiceType("chest.v1.CipherChestService", [
    { name: "ListChests", options: {}, I: ListChestsRequest, O: ListChestsResponse },
    { name: "GetTrymap", options: {}, I: GetTrymapRequest, O: GetTrymapResponse },
    { name: "SubmitGuess", options: {}, I: SubmitGuessRequest, O: SubmitGuessResponse },
    { name: "SetNotification", options: {}, I: SetNotificationRequest, O: SetNotificationResponse }
]);
